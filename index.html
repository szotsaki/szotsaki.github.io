<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>GrainAutLine documentation by szotsaki</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">GrainAutLine documentation</h1>
      <h2 class="project-tagline"></h2>
    </section>

    <section class="main-content">
      <h1>
<a id="my-first-hello-world-processor" class="anchor" href="#my-first-hello-world-processor" aria-hidden="true"><span class="octicon octicon-link"></span></a>My first „Hello World!” processor!</h1>

<p>This guide will show you how to create the new processor of yours, add some layers to it and set their properties.</p>

<p><em>A bit of disclaimer: this guide will continuously evolve as developer documentations do. But hey, it exists! So it worth to come back from time to time or subscribe to its change-notification. The latest state of this text always reflects the HEAD version of branch „szotsaki”. Generally speaking, if something doesn't work for you, just merge and recompile everything.</em></p>

<h2>
<a id="so-the-basics" class="anchor" href="#so-the-basics" aria-hidden="true"><span class="octicon octicon-link"></span></a>So, the basics</h2>

<p>You want to write a processor which does some calculations. You also want to show your work and later maybe interact with it on the GUI. For all of these you are needed to deal with three classes:</p>

<ol>
<li>
<code>Processor</code>: of course this is the most important one. All the essence of your work goes mostly here.</li>
<li>
<code>Layer</code>: if you want some show-off, you'll also need this. Or these. You have the possibility to attach more layers to a processor. Or none. It's truly your choice whether you want to show something to the world.</li>
<li>
<code>ProcessorSlot</code>: last but not least, a structure is needed which encompasses these aforementioned classes together. You won't need to care about this much though, its defaults are just perfect.</li>
</ol>

<h3>
<a id="processors" class="anchor" href="#processors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Processors</h3>

<p>First, start with the <code>Processor</code>. It has a <em>name</em> and arbitrary number of custom <em>properties</em>. The processor-related files are stored with the model, in the <tt>MarbeCommon/Processors</tt> directory. To create your first processor, let's call it <code>FirstProcessor</code>, you have to subclass from the abstract <code>Processor</code> class like this:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">class</span> <span class="pl-en">FirstProcessor</span> : <span class="pl-k">public</span> <span class="pl-en">Processor</span>
{
    Q_OBJECT
<span class="pl-k">public:</span>
    <span class="pl-en">FirstProcessor</span>(QObject *parent = <span class="pl-v">nullptr</span>);
    <span class="pl-en">~FirstProcessor</span>() = <span class="pl-k">default</span>;
}<span class="pl-ii"></span></pre></div>

<p>The <code>Q_OBJECT</code> macro is necessary because of some boring administration reasons. The <code>parent</code> pointer is necessary because <a href="http://www.qt.io/">Qt</a> maintains a hierarchy of the declared objects for easier deletion among others. After that you see the constructor and destructor. Here is, how to define this class:</p>

<div class="highlight highlight-c++"><pre><span class="pl-en">FirstProcessor::FirstProcessor</span>(QObject *parent)
    : Processor(<span class="pl-s"><span class="pl-pds">"</span>My first Processor<span class="pl-pds">"</span></span>, parent)
{
}</pre></div>

<p>We pass the name of our processor (which will be shown on the GUI) to the parent constructor.</p>

<h3>
<a id="layers" class="anchor" href="#layers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Layers</h3>

<p>Now, head towards to the <code>Layers</code>.</p>

<p>The resemblance is uncanny with the processors. You will just have to create a new <code>Layer</code> class of yours (call it, for the sake of simplicity, <code>FirstLayer</code>), make it a descendant of the <code>Layer</code> abstract class and pass your <em>layer's name</em> to the parent constructor. The layer-related files lie with other GUI files, in the <tt>GrainAutLine/Layers</tt> directory. A very basic implementation would look like this:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">class</span> <span class="pl-en">FirstLayer</span> : <span class="pl-k">public</span> <span class="pl-en">Layer</span>
{
    Q_OBJECT
<span class="pl-k">public:</span>
    <span class="pl-k">explicit</span> <span class="pl-en">FirstLayer</span>(QObject *parent = <span class="pl-v">nullptr</span>);
    <span class="pl-en">~FirstLayer</span>() = <span class="pl-k">default</span>;
}<span class="pl-ii"></span></pre></div>

<div class="highlight highlight-c++"><pre><span class="pl-en">FirstLayer::FirstLayer</span>(QObject *parent)
    : Layer(<span class="pl-s"><span class="pl-pds">"</span>My first layer<span class="pl-pds">"</span></span>, parent)
{
}</pre></div>

<h3>
<a id="the-processorslot" class="anchor" href="#the-processorslot" aria-hidden="true"><span class="octicon octicon-link"></span></a>The ProcessorSlot</h3>

<p>Let's finish with the encapsulating class, the <code>ProcessorSlot</code>.</p>

<p>First, you need to shortly name your work you did so far. The name of the compilation will appear only in code but it should be expressive for other developers. Register this name in the <code>ProcessorSlot::Type</code> enumeration. Now you can create a new specific instance of <code>ProcessorSlot</code>: please, usher yourself to the hall of the <code>ProcessorSlot</code> constructor and supplement the switch-case structure with the name of your choice.</p>

<p>The <code>Processor_</code> variable will hold your custom processor. Create a new instance of it:</p>

<div class="highlight highlight-c++"><pre>Processor_ = std::make_shared&lt;FirstProcessor&gt;(<span class="pl-v">this</span>);</pre></div>

<p>The <code>Layers</code> vector holds all the layers you want to use later. Previously we created only one, <code>FirstLayer</code>, but feel free to either add it multiple times or create many different layers later and add them here:</p>

<div class="highlight highlight-c++"><pre>Layers.push_back(std::make_shared&lt;FirstLayer&gt;(<span class="pl-v">this</span>));</pre></div>

<p>Note that layers are optional extensions for a <code>Processor</code> determined to show the internal state of the latter. Therefore it's not necessary to attach a layer at all.</p>

<h3>
<a id="the-almighty-encapsulator-the-slotmanager" class="anchor" href="#the-almighty-encapsulator-the-slotmanager" aria-hidden="true"><span class="octicon octicon-link"></span></a>The almighty encapsulator: the SlotManager</h3>

<p>Maybe there's a slight chance you've been wondering if there is an encapsulation class for <code>Layers</code> and <code>Processors</code> (this is the <code>ProcessorSlot</code>), is there a similar container for many <code>ProcessorSlots</code>? Yes, there is. It is called <code>SlotManager</code> which, not surprisingly, manages the life cycles of <code>ProcessorSlots</code>.</p>

<p>When you are ready with your modifications so far, you are needed to register your <code>ProcessorSlot</code> in <code>SlotManager</code>. This is quite easy, just add your class to the following container in its constructor like this:</p>

<div class="highlight highlight-c++"><pre>NonElementarySlots.push_back(
    std::make_shared&lt;ProcessorSlot&gt;(ProcessorSlot::Type::MyFirstProcessorSlot, <span class="pl-v">this</span>)
  );</pre></div>

<p>Make sure that you replace <code>MyFirstProcessorSlot</code> with the name you used previously in the enumeration.</p>

<h3>
<a id="finishing" class="anchor" href="#finishing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Finishing</h3>

<p>You created a new  <code>Processor</code> and a new <code>Layer</code>. Then you added them to the their encapsulation class, <code>ProcessorSlot</code>. After that you registered this processor slot at their manager, <code>SlotManager</code>.</p>

<p>Now, we are ready. Oh, just one thing: make sure that your processor computes and layer draws. How easy to say that, isn't it? Well, it will surely be a joyful journey. For the beginning, define and override the following functions:</p>

<ul>
<li>for the computation itself:</li>
</ul>

<div class="highlight highlight-c++"><pre><span class="pl-k">virtual</span> <span class="pl-k">bool</span> <span class="pl-en">FirstProcessor::Step</span>(ProcessingStateDescriptor&amp; psd) <span class="pl-k">override</span>;</pre></div>

<ul>
<li>and for the drawing:</li>
</ul>

<div class="highlight highlight-c++"><pre><span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">FirstLayer::Render</span>(<span class="pl-k">const</span> ProcessingStateDescriptor&amp; psd) <span class="pl-k">override</span>;</pre></div>

<p>Have a nice time coding!</p>

<h1>
<a id="reference-documentation" class="anchor" href="#reference-documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference documentation</h1>

<p>From now on, we are going through the different trifles of the API to make you get most out of the programming interface.</p>

<h2>
<a id="processorslot" class="anchor" href="#processorslot" aria-hidden="true"><span class="octicon octicon-link"></span></a>ProcessorSlot</h2>

<p>As we saw prevously, a <code>ProcessorSlot</code> encompasses exactly one <code>Processor</code> and an arbitrary number of <code>Layers</code>.</p>

<h3>
<a id="elementary-processorslots" class="anchor" href="#elementary-processorslots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Elementary ProcessorSlots</h3>

<p>An <em>elementary</em> <code>ProcessorSlot</code> has the following properties:</p>

<ul>
<li>Its <code>Processor</code> always runs regardless of everything. This is necessary for making such fundamental tasks done like the raw image rendering.</li>
<li>Its <code>Processor</code> name doesn't show up in the drop-down processor selector list on the GUI, so it cannot be selected to run alone.</li>
<li>This infers that an elementary <code>Processor</code> cannot have properties configured from the GUI, since its property window will never be displayed.</li>
<li>Nevertheless, it still can have as many layers as you want and these layers are always shown until the user decides to turn them off.</li>
<li>An elementary <code>ProcessorSlot</code> (and its containees) by default don't receive mouse events, however this can be configured in <code>SlotManager</code> constructor following to the comment there.</li>
</ul>

<p>To make a <code>ProcessorSlot</code> elementary, just set the <code>Elementary_</code> variable to <code>true</code> in the <code>ProcessorSlot</code> constructor. Just like the following example does:</p>

<div class="highlight highlight-c++"><pre>[…]
<span class="pl-k">case</span> Type::ShowImage:
        Processor_ = std::make_shared&lt;ShowImageProcessor&gt;(<span class="pl-v">this</span>);
        Layers.push_back(std::make_shared&lt;ShowImageLayer&gt;(<span class="pl-v">this</span>));
        Elementary_ = <span class="pl-c1">true</span>;
        <span class="pl-k">break</span>;
[…]</pre></div>

<p>This property cannot be modified at run-time.</p>

<p>Please, pay attention to instantiate your elementary <code>ProcessorSlot</code> in the right section of the <code>SlotManager</code> constructor. A comment line indicates where these are going.</p>

<h3>
<a id="supplementary-canvas" class="anchor" href="#supplementary-canvas" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supplementary canvas</h3>

<p>A <em>supplementary canvas</em> is a small area displaying custom layers which is bound to a <code>ProcessorSlot</code> and shown on the right hand side of the GUI.</p>

<p>This feature is under construction; please check back a while later for documentation.</p>

<h2>
<a id="processor" class="anchor" href="#processor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Processor</h2>

<h3>
<a id="processor-properties" class="anchor" href="#processor-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Processor properties</h3>

<p>A processor is a rather complex entity, therefore it needs some <em>properties</em> to fine-tune itself. These properties are shown on the GUI and freely configurable by the user. All properties have a unique <em>name</em>, a <em>default value</em> and of course they hold their <em>current value</em>.</p>

<p>To add a property to your <code>Processor</code>, simply call the <code>AddProperty</code> method in your <code>Processor</code> constructor.</p>

<p>Currently, there are two different kinds of properties you can use:</p>

<ol>
<li>
<p><em>Float type</em>: You can store a <code>float</code> value inside with a <em>minimum</em> and <em>maximum</em> range provided.</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">AddProperty</span>(<span class="pl-k">const</span> QString&amp; name,
                 <span class="pl-k">const</span> <span class="pl-k">float</span> minimum,
                 <span class="pl-k">const</span> <span class="pl-k">float</span> maximum,
                 <span class="pl-k">const</span> <span class="pl-k">float</span> default_);</pre></div>

<p>Reading its value is possible by its name with the following function:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">float</span> <span class="pl-en">GetFloatPropertyValue</span>(<span class="pl-k">const</span> QString&amp; name);</pre></div>
</li>
<li>
<p><em>Boolean type</em>: You can store a <code>bool</code> value inside.</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">AddProperty</span>(<span class="pl-k">const</span> QString&amp; name,
                 <span class="pl-k">const</span> <span class="pl-k">bool</span> default_);</pre></div>

<p>Reading its value is possible by its name with the following function:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">bool</span> <span class="pl-en">GetBoolPropertyValue</span>(<span class="pl-k">const</span> QString&amp; name);</pre></div>
</li>
</ol>

<h3>
<a id="overriding-run" class="anchor" href="#overriding-run" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overriding Run()</h3>

<p>A <code>Processor</code> works this simplified way: when a mouse click occurred or a new image file was loaded, the <code>Run</code> method starts and calls <code>Step</code> until it returns <code>false</code>. If you need more elaborate control, you can override this method. Its default implementation looks like the following:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">Processor::Run</span>(ProcessingStateDescriptor&amp; psd)
{
    <span class="pl-k">while</span>(<span class="pl-c1">Step</span>(psd) == <span class="pl-c1">true</span>)
        ;

    emit <span class="pl-smi">ComputationReady</span>(psd);
}</pre></div>

<p>Please, always emit the <code>ComputationReady</code> signal when the <code>Run</code> process finishes.</p>

<h3>
<a id="subscribing-to-the-mouse-click-events" class="anchor" href="#subscribing-to-the-mouse-click-events" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subscribing to the mouse click events</h3>

<p>By default the <code>Processor</code> doesn't receive mouse click events. If you want your <code>Processor</code> receive them, redefine the <code>ReceiveMouseClicks()</code> function and return with true. You can modifiy its return value anytime you want, the changes will come to effect when a new <code>Processor</code> is selected on the GUI.</p>

<p>Please note that regardless you are subscribed to the mouse click events, your <code>Processor</code> won't receive them if it's not the currently selected one.</p>

<p>Please also note that this sub-chapter only applies to non-elementary processors. For elementary processors refer to the <a href="#elementary-processorslots">Elementary ProcessorSlots</a>  chapter.</p>

<h3>
<a id="run-on-mouse-click" class="anchor" href="#run-on-mouse-click" aria-hidden="true"><span class="octicon octicon-link"></span></a>Run on mouse click</h3>

<p>Virtual function <code>MouseClicked</code> is implemented in a way if the <code>Processor</code> receives the click event, store the coordinates and start the <code>Run</code> method.</p>

<p>If you want another behaviour, override this aforementioned function which is automatically called if a click event occurred and the <code>Processor</code> was subscribed to it:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">MouseClicked</span>(<span class="pl-k">const</span> QString&amp; canvasName,
                          <span class="pl-k">const</span> QPointF&amp; coordinates,
                          ProcessingStateDescriptor&amp; psd)</pre></div>

<h3>
<a id="getting-the-current-mouse-coordinates" class="anchor" href="#getting-the-current-mouse-coordinates" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting the current mouse coordinates</h3>

<p>When a mouse click occurred and the processor is set to receive the mouse click events, you can be sure that the <code>MouseCoordinates</code> member contains the current position. If no click occurred (e.g. after an image loaded), this member contains the (0, 0) coordinate.</p>

<p>The top-left image coordinate is (0, 0) and is resize-agnostic.</p>

<p>On reading out the value from this member, please refer to the <a href="http://doc.qt.io/qt-5/qpointf.html">QPointF documentation</a>.</p>

<h2>
<a id="layers-1" class="anchor" href="#layers-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Layers</h2>

<p>A <code>Layer</code> renders a bit of portion of the main image which will be blended into the renderings of other layers. After all the layers created their own <code>cv::Mat</code> image, the so called <code>ImageProvider</code> collects and flattens them into the final image which will be shown to user on the canvas(es).</p>

<p>The layer concept is under construction, so the documentation is unfinished yet.</p>

<h3>
<a id="accessing-to-its-processor" class="anchor" href="#accessing-to-its-processor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Accessing to its Processor</h3>

<p>It is an easy task since it involves only calling the <code>GetProcessor</code> getter from anywhere inside the Layer's function. Calling this getter it's your responsibility to specify exactly that type of <code>Processor</code> which belongs to the current <code>Layer</code>. The return value of this function is a <code>std::shared_ptr</code> so handle it like a normal pointer type.</p>

<p>An example which calls the custom <code>CreateMagic()</code> function of your <code>FirstProcessor</code>:</p>

<div class="highlight highlight-c++"><pre>GetProcessor&lt;FirstProcessor&gt;()-&gt;<span class="pl-en">CreateMagic</span>();</pre></div>

<h3>
<a id="sequences" class="anchor" href="#sequences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sequences</h3>

<p>Each <code>Layer</code> has a number, called <code>Sequence</code>. This defines the order of layers to render on each other. You can query this number if you need by using member function <code>GetSequence</code> but please, by any means, do <em>not</em> ever change this value!</p>

<h3>
<a id="rendering" class="anchor" href="#rendering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rendering</h3>

<p>This is the function in you are free to leverage your creativity. One thing you need to pay a bit attention to: always emit the <em>iAmReadyWithRendering</em> signal, here called <code>RenderReady</code>. For example like this:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">FirstLayer::Render</span>(<span class="pl-k">const</span> ProcessingStateDescriptor&amp; psd)
{
    <span class="pl-c">// Generate image to cv::Mat</span>
    <span class="pl-k">const</span> cv::Mat image = psd.<span class="pl-c1">ExportToImage</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);

    emit <span class="pl-smi">RenderReady</span>(<span class="pl-c1">GetSequence</span>(), image, <span class="pl-c1">true</span>);
}</pre></div>

<p>The signal signature is the following:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">RenderReady</span>(<span class="pl-k">const</span> <span class="pl-k">int</span> layerSequence, <span class="pl-c">// Sequence ID of the current layer</span>
                 <span class="pl-k">const</span> cv::Mat&amp; mat,      <span class="pl-c">// The finished image in cv::Mat format</span>
                 <span class="pl-k">const</span> <span class="pl-k">bool</span> dirty);       <span class="pl-c">// true only if the cv::Mat has been changed</span></pre></div>

<h3>
<a id="caching" class="anchor" href="#caching" aria-hidden="true"><span class="octicon octicon-link"></span></a>Caching</h3>

<p>Since converting many cv::Mats from the processors on every pixel the mouse advanced to can be a really time consuming operation, always use cache. If the <code>Layer</code> knows that the image didn't change, recall the previously rendered <code>cv::Mat</code> from member variable <code>Cache</code>. An example showing this:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">ShowImageLayer::Render</span>(<span class="pl-k">const</span> ProcessingStateDescriptor &amp;psd)
{
    <span class="pl-k">bool</span> dirty = <span class="pl-c1">true</span>;

    <span class="pl-k">if</span> (Cache.<span class="pl-smi">data</span> == <span class="pl-v">nullptr</span>) {
        cv::Mat imgOriginal = <span class="pl-c1">cv::imread</span>(psd.<span class="pl-smi">ImageFileName</span>, CV_LOAD_IMAGE_COLOR);
        <span class="pl-c1">Q_ASSERT</span>(imgOriginal.<span class="pl-smi">data</span>);

        Cache = imgOriginal;
    } <span class="pl-k">else</span> {
        dirty = <span class="pl-c1">false</span>;
    }

    emit <span class="pl-smi">RenderReady</span>(<span class="pl-c1">GetSequence</span>(), Cache, dirty);
}</pre></div>

<p>Beware that your condition on invalidating the cache might be different.</p>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

