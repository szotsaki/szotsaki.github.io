<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>GrainAutLine documentation by szotsaki</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">GrainAutLine documentation</h1>
      <h2 class="project-tagline"></h2>
    </section>

    <section class="main-content">
      <h1>
<a id="my-first-hello-world-processor" class="anchor" href="#my-first-hello-world-processor" aria-hidden="true"><span class="octicon octicon-link"></span></a>My first „Hello World!” processor!</h1>

<p>This guide will show you how to create the new processor of yours, add some layers to it and set their properties.</p>

<p><em>A bit of disclaimer: this guide will continuously evolve as developer documentations do. But hey, it exists! So it worth to come back from time to time or subscribe to its change-notification. The latest state of this text always reflects the HEAD version of branch „szotsaki”. Generally speaking, if something doesn't work for you, just merge and recompile everything.</em></p>

<h2>
<a id="so-the-basics" class="anchor" href="#so-the-basics" aria-hidden="true"><span class="octicon octicon-link"></span></a>So, the basics</h2>

<p>You want to write a processor which does some calculations. You also want to show your work and later maybe interact with it on the GUI. For all of these you are needed to deal with three classes:</p>

<ol>
<li>
<code>Processor</code>: of course this is the most important one. All the essence of your work goes mostly here.</li>
<li>
<code>Layer</code>: if you want some show-off, you'll also need this. Or these. You have the possibility to attach more layers to a processor. Or none. It's truly your choice whether you want to show something to the world.</li>
<li>
<code>ProcessorSlot</code>: last but not least, a structure is needed which encompasses these aforementioned classes together. You won't need to care about this much though, its defaults are just perfect.</li>
</ol>

<h3>
<a id="processors" class="anchor" href="#processors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Processors</h3>

<p>First, start with the <code>Processor</code>. It has a <em>name</em> and arbitrary number of custom <em>properties</em>. The processor-related files are stored with the model, in the <tt>MarbeCommon/Processors</tt> directory. To create your first processor, let's call it <code>FirstProcessor</code>, you have to subclass from the abstract <code>Processor</code> class like this:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">class</span> <span class="pl-en">FirstProcessor</span> : <span class="pl-k">public</span> <span class="pl-en">Processor</span>
{
    Q_OBJECT
<span class="pl-k">public:</span>
    <span class="pl-en">FirstProcessor</span>(QObject *parent = <span class="pl-v">nullptr</span>);
    <span class="pl-en">~FirstProcessor</span>() = <span class="pl-k">default</span>;
}<span class="pl-ii"></span></pre></div>

<p>The <code>Q_OBJECT</code> macro is necessary because of some boring administration reasons. The <code>parent</code> pointer is necessary because <a href="http://www.qt.io/">Qt</a> maintains a hierarchy of the declared objects for easier deletion among others. After that you see the constructor and destructor. Here is, how to define this class:</p>

<div class="highlight highlight-c++"><pre><span class="pl-en">FirstProcessor::FirstProcessor</span>(QObject *parent)
    : Processor(<span class="pl-s"><span class="pl-pds">"</span>My first Processor<span class="pl-pds">"</span></span>, parent)
{
}</pre></div>

<p>We pass the name of our processor (which will be shown on the GUI) to the parent constructor.</p>

<h3>
<a id="layers" class="anchor" href="#layers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Layers</h3>

<p>Now, head towards to the <code>Layers</code>.</p>

<p>The resemblance is uncanny with the processors. You will just have to create a new <code>Layer</code> class of yours (call it, for the sake of simplicity, <code>FirstLayer</code>), make it a descendant of the <code>Layer</code> abstract class and pass your <em>layer's name</em> to the parent constructor. The layer-related files lie with other GUI files, in the <tt>GrainAutLine/Layers</tt> directory. A very basic implementation would look like this:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">class</span> <span class="pl-en">FirstLayer</span> : <span class="pl-k">public</span> <span class="pl-en">Layer</span>
{
    Q_OBJECT
<span class="pl-k">public:</span>
    <span class="pl-k">explicit</span> <span class="pl-en">FirstLayer</span>(QObject *parent = <span class="pl-v">nullptr</span>);
    <span class="pl-en">~FirstLayer</span>() = <span class="pl-k">default</span>;
}<span class="pl-ii"></span></pre></div>

<div class="highlight highlight-c++"><pre><span class="pl-en">FirstLayer::FirstLayer</span>(QObject *parent)
    : Layer(<span class="pl-s"><span class="pl-pds">"</span>My first layer<span class="pl-pds">"</span></span>, parent)
{
}</pre></div>

<h3>
<a id="the-processorslot" class="anchor" href="#the-processorslot" aria-hidden="true"><span class="octicon octicon-link"></span></a>The ProcessorSlot</h3>

<p>Let's finish with the encapsulating class, the <code>ProcessorSlot</code>.</p>

<p>First, you need to shortly name your work you did so far. The name of the compilation will appear only in code but it should be expressive for other developers. Register this name in the <code>ProcessorSlot::Type</code> enumeration. Now you can create a new specific instance of <code>ProcessorSlot</code>: please, usher yourself to the hall of the <code>ProcessorSlot</code> constructor and supplement the switch-case structure with the name of your choice.</p>

<p>The <code>Processor_</code> variable will hold your custom processor. Create a new instance of it:</p>

<div class="highlight highlight-c++"><pre>Processor_ = std::make_shared&lt;FirstProcessor&gt;(<span class="pl-v">this</span>);</pre></div>

<p>The <code>Layers</code> vector holds all the layers you want to use later. Previously we created only one, <code>FirstLayer</code>, but feel free to either add it multiple times or create many different layers later and add them here:</p>

<div class="highlight highlight-c++"><pre>Layers.push_back(std::make_shared&lt;FirstLayer&gt;(<span class="pl-v">this</span>));</pre></div>

<p>Note that layers are optional extensions for a <code>Processor</code> determined to show the internal state of the latter. Therefore it's not necessary to attach a layer at all.</p>

<h3>
<a id="the-almighty-encapsulator-the-slotmanager" class="anchor" href="#the-almighty-encapsulator-the-slotmanager" aria-hidden="true"><span class="octicon octicon-link"></span></a>The almighty encapsulator: the SlotManager</h3>

<p>Maybe there's a slight chance you've been wondering if there is an encapsulation class for <code>Layers</code> and <code>Processors</code> (this is the <code>ProcessorSlot</code>), is there a similar container for many <code>ProcessorSlots</code>? Yes, there is. It is called <code>SlotManager</code> which, not surprisingly, manages the life cycles of <code>ProcessorSlots</code>.</p>

<p>When you are ready with your modifications so far, you are needed to register your <code>ProcessorSlot</code> in <code>SlotManager</code>. This is quite easy, just add your class to the following container in its constructor like this:</p>

<div class="highlight highlight-c++"><pre>NonElementarySlots.push_back(
    std::make_shared&lt;ProcessorSlot&gt;(ProcessorSlot::Type::MyFirstProcessorSlot, <span class="pl-v">this</span>)
  );</pre></div>

<p>Make sure that you replace <code>MyFirstProcessorSlot</code> with the name you used previously in the enumeration.</p>

<h3>
<a id="finishing" class="anchor" href="#finishing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Finishing</h3>

<p>You created a new  <code>Processor</code> and a new <code>Layer</code>. Then you added them to the their encapsulation class, <code>ProcessorSlot</code>. After that you registered this processor slot at their manager, <code>SlotManager</code>.</p>

<p>Now, we are ready. Oh, just one thing: make sure that your processor computes and layer draws. How easy to say that, isn't it? Well, it will surely be a joyful journey. For the beginning, define and override the following functions:</p>

<ul>
<li>for the computation itself:</li>
</ul>

<div class="highlight highlight-c++"><pre><span class="pl-k">virtual</span> <span class="pl-k">bool</span> <span class="pl-en">FirstProcessor::Step</span>(ProcessingStateDescriptor&amp; psd) <span class="pl-k">override</span>;</pre></div>

<ul>
<li>and for the drawing:</li>
</ul>

<div class="highlight highlight-c++"><pre><span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">FirstLayer::Render</span>(<span class="pl-k">const</span> ProcessingStateDescriptor&amp; psd) <span class="pl-k">override</span>;</pre></div>

<p>Have a nice time coding!</p>

<h1>
<a id="reference-documentation" class="anchor" href="#reference-documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference documentation</h1>

<p>From now on, we are going through the different trifles of the API to make you get most out of the programming interface.</p>

<h2>
<a id="processorslot" class="anchor" href="#processorslot" aria-hidden="true"><span class="octicon octicon-link"></span></a>ProcessorSlot</h2>

<p>As we saw previously, a <code>ProcessorSlot</code> encompasses exactly one <code>Processor</code> and an arbitrary number of <code>Layers</code>.</p>

<h3>
<a id="elementary-processorslots" class="anchor" href="#elementary-processorslots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Elementary ProcessorSlots</h3>

<p>An <em>elementary</em> <code>ProcessorSlot</code> has the following properties:</p>

<ul>
<li>Its <code>Processor</code> always runs regardless of everything. This is necessary for making such fundamental tasks done like the raw image rendering.</li>
<li>Its <code>Processor</code> name doesn't show up in the drop-down processor selector list on the GUI, so it cannot be selected to run alone.</li>
<li>This infers that an elementary <code>Processor</code> cannot have properties configured from the GUI, since its property window will never be displayed.</li>
<li>Nevertheless, it still can have as many layers as you want and these layers are always shown until the user decides to turn them off.</li>
</ul>

<p>To make a <code>ProcessorSlot</code> elementary, just set the <code>Elementary_</code> variable to <code>true</code> in the <code>ProcessorSlot</code> constructor. Just like the following example does:</p>

<div class="highlight highlight-c++"><pre>[…]
<span class="pl-k">case</span> Type::ShowImage:
        Processor_ = std::make_shared&lt;ShowImageProcessor&gt;(<span class="pl-v">this</span>);
        Layers.push_back(std::make_shared&lt;ShowImageLayer&gt;(<span class="pl-v">this</span>));
        Elementary_ = <span class="pl-c1">true</span>;
        <span class="pl-k">break</span>;
[…]</pre></div>

<p>This property cannot be modified at run-time.</p>

<p>Please, pay attention to instantiate your elementary <code>ProcessorSlot</code> in the right section of the <code>SlotManager</code> constructor. A comment line indicates where these are going.</p>

<h2>
<a id="processor" class="anchor" href="#processor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Processor</h2>

<h3>
<a id="processor-properties" class="anchor" href="#processor-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Processor properties</h3>

<p>A processor is a rather complex entity, therefore it needs some <em>properties</em> to fine-tune itself. These properties are shown on the GUI and freely configurable by the user. All properties have a unique <em>name</em>, a <em>default value</em> and of course they hold their <em>current value</em>.</p>

<p>To add a property to your <code>Processor</code>, simply call the <code>AddProperty</code> method in your <code>Processor</code> constructor.</p>

<p>Currently, there are two different kinds of properties you can use:</p>

<ol>
<li>
<p><em>Float type</em>: You can store a <code>float</code> value inside with a <em>minimum</em> and <em>maximum</em> range provided.</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">AddProperty</span>(<span class="pl-k">const</span> QString&amp; name,
                 <span class="pl-k">const</span> <span class="pl-k">float</span> minimum,
                 <span class="pl-k">const</span> <span class="pl-k">float</span> maximum,
                 <span class="pl-k">const</span> <span class="pl-k">float</span> default_);</pre></div>

<p>Reading its value is possible by its name with the following function:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">float</span> <span class="pl-en">GetFloatPropertyValue</span>(<span class="pl-k">const</span> QString&amp; name);</pre></div>
</li>
<li>
<p><em>Boolean type</em>: You can store a <code>bool</code> value inside.</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">AddProperty</span>(<span class="pl-k">const</span> QString&amp; name,
                 <span class="pl-k">const</span> <span class="pl-k">bool</span> default_);</pre></div>

<p>Reading its value is possible by its name with the following function:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">bool</span> <span class="pl-en">GetBoolPropertyValue</span>(<span class="pl-k">const</span> QString&amp; name);</pre></div>
</li>
</ol>

<h3>
<a id="overriding-run" class="anchor" href="#overriding-run" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overriding Run()</h3>

<p>A <code>Processor</code> works this simplified way: when a mouse click occurred or a new image file was loaded, the <code>Run</code> method starts and calls <code>Step</code> until it returns <code>false</code>. If you need more elaborate control, you can override this method. Its default implementation looks like the following:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">Processor::Run</span>(ProcessingStateDescriptor&amp; psd)
{
    <span class="pl-k">while</span>(<span class="pl-c1">Step</span>(psd) == <span class="pl-c1">true</span>)
        ;

    emit <span class="pl-smi">ComputationReady</span>(psd);
}</pre></div>

<p>Please, always emit the <code>ComputationReady</code> signal when the <code>Run</code> process finishes.</p>

<h3>
<a id="mouse-handling" class="anchor" href="#mouse-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mouse handling</h3>

<h4>
<a id="subscribing-to-the-mouse-events" class="anchor" href="#subscribing-to-the-mouse-events" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subscribing to the mouse events</h4>

<p>There are four types of mouse events exist:</p>

<table>
<thead>
<tr>
<th>Constant</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>QEvent::MouseButtonPress</td>
<td>Mouse press</td>
</tr>
<tr>
<td>QEvent::MouseButtonRelease</td>
<td>Mouse release</td>
</tr>
<tr>
<td>QEvent::MouseButtonDblClick</td>
<td>Mouse press again</td>
</tr>
<tr>
<td>QEvent::MouseMove</td>
<td>Mouse move</td>
</tr>
</tbody>
</table>

<p>The <code>MouseButtonRelease</code> is e.g. useful for one-shot actions like running the processor after a click was made at a certain coordinate. While the <code>MouseMove</code> is best for continuous actions like drawing. You can freely subscribe to each of them independently with your processor.</p>

<p>By default, a <code>Processor</code> doesn't receive these mouse events. To do so, add the desired ones to the <code>SubscribedMouseEvents</code> <a href="http://www.cplusplus.com/reference/unordered_set/unordered_set/"><code>unordered_set</code></a> structure like this:</p>

<div class="highlight highlight-c++"><pre>SubscribedMouseEvents = {QEvent::MouseButtonRelease, QEvent::MouseMove};</pre></div>

<p>You may add them directly at the construction time of your class, although you can modify these values any time you want; the changes will come into effect before the next run of your <code>Processor</code>.</p>

<p>Please note that regardless you are subscribed to the mouse events, your <code>Processor</code> won't receive them if it's not the currently selected one.</p>

<h4>
<a id="reacting-to-a-mouse-event" class="anchor" href="#reacting-to-a-mouse-event" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reacting to a mouse event</h4>

<p>Supposing you're already subscribed to the desired mouse events, your processor will receive them in the following <code>virtual</code> function:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">MouseEventOccurred</span>(<span class="pl-k">const</span> QMouseEvent&amp; event,
                                <span class="pl-k">const</span> QString&amp; canvasName,
                                ProcessingStateDescriptor&amp; psd)</pre></div>

<p>The first variable contains the event itself. You can determine its type by using the <code>type()</code> function of its. For example if you are subscribed to the previously mentioned events, you can distinguish between them in the following way:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">MyFirstProcessor::MouseEventOccurred</span>(<span class="pl-k">const</span> QMouseEvent &amp;event, <span class="pl-k">const</span> QString &amp;canvasName, ProcessingStateDescriptor &amp;psd)
{
    <span class="pl-c">// Refresh the MouseEvent variable both on QEvent::MouseButtonRelease and QEvent::MouseMove</span>
    MouseEvent = event;

    <span class="pl-k">if</span> (event.<span class="pl-c1">type</span>() == QEvent::MouseButtonRelease) {
        <span class="pl-c1">MouseClicked</span>(canvasName, psd);
    }
}</pre></div>

<p>The default implementation of this function stores the <code>QMouseEvent</code> object into the <code>MouseEvent</code> member variable. In case you don't need extra handling of the events, you may not want to override this function, just read the <code>MouseEvent</code> member from your <code>Processor</code>.</p>

<h4>
<a id="getting-the-current-mouse-coordinates" class="anchor" href="#getting-the-current-mouse-coordinates" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting the current mouse coordinates</h4>

<p>When a mouse event occurred and the processor is set to receive these events, by default the <code>MouseEvent</code> member contains the current event with its position. Use the <code>pos</code> or <code>localPos</code> functions to read out these coordinates. Please, refer to the <a href="http://doc.qt.io/qt-5/qmouseevent.html">QMouseEvent</a> and <a href="http://doc.qt.io/qt-5/qpoint.html">QPoint</a> documentation on handling these values.</p>

<p>Please note that because of performance reasons functions <code>screenPos</code>, <code>windowPos</code> and <code>globalPos</code> always return with <code>QPoint(0, 0)</code>.</p>

<p>The top-left image coordinate is (0, 0) and the given coordinates are always resize-agnostics.</p>

<h2>
<a id="layers-1" class="anchor" href="#layers-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Layers</h2>

<p>A <code>Layer</code> renders a bit of portion of the main image which will be blended into the renderings of other layers. After all the layers created their own <code>cv::Mat</code> image, the so called <code>ImageProvider</code> collects and flattens them into the final image which will be shown to user on the canvas(es).</p>

<h3>
<a id="accessing-to-its-processor" class="anchor" href="#accessing-to-its-processor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Accessing to its Processor</h3>

<p>It is an easy task since it involves only calling the <code>GetProcessor</code> getter from anywhere inside the Layer's function. Calling this getter it's your responsibility to specify exactly that type of <code>Processor</code> which belongs to the current <code>Layer</code>. The return value of this function is a <code>std::shared_ptr</code> so handle it like a normal pointer type.</p>

<p>An example which calls the custom <code>CreateMagic()</code> function of your <code>FirstProcessor</code>:</p>

<div class="highlight highlight-c++"><pre>GetProcessor&lt;FirstProcessor&gt;()-&gt;<span class="pl-en">CreateMagic</span>();</pre></div>

<h3>
<a id="sequences" class="anchor" href="#sequences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sequences</h3>

<p>Each <code>Layer</code> has a number, called <code>Sequence</code>. This defines the order of layers to render on each other. You can query this number if you need by using member function <code>GetSequence</code> but please, by any means, do <em>not</em> ever change this value!</p>

<h3>
<a id="rendering" class="anchor" href="#rendering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rendering</h3>

<p>This is the function in you are free to leverage your creativity. One thing you need to pay a bit attention to: emit the <em>iAmReadyWithRendering</em> signal, here called <code>RenderReady</code> if you want your layer image to be shown. For example like this:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">FirstLayer::Render</span>(<span class="pl-k">const</span> ProcessingStateDescriptor&amp; psd)
{
    <span class="pl-c">// Generate image to cv::Mat</span>
    <span class="pl-k">const</span> cv::Mat image = psd.<span class="pl-c1">ExportToImage</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);

    emit <span class="pl-smi">RenderReady</span>(<span class="pl-c1">GetTargetCanvas</span>(), <span class="pl-c1">GetSequence</span>(), image, <span class="pl-c1">GetOpacity</span>(), <span class="pl-c1">true</span>);
}</pre></div>

<p>The signal signature is the following:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">RenderReady</span>(<span class="pl-k">const</span> QString&amp; canvasName, <span class="pl-c">// Name of the canvas to draw on</span>
                 <span class="pl-k">const</span> <span class="pl-k">int</span> layerSequence,   <span class="pl-c">// Sequence ID of the current layer</span>
                 <span class="pl-k">const</span> cv::Mat&amp; mat,        <span class="pl-c">// The finished image in cv::Mat format</span>
                 <span class="pl-k">const</span> <span class="pl-k">float</span> opacity,       <span class="pl-c">// Opacity of the current layer set on the GUI</span>
                 <span class="pl-k">const</span> <span class="pl-k">bool</span> dirty);         <span class="pl-c">// true only if the cv::Mat has been changed</span></pre></div>

<h3>
<a id="caching" class="anchor" href="#caching" aria-hidden="true"><span class="octicon octicon-link"></span></a>Caching</h3>

<p>Since converting many cv::Mats from the processors on every pixel the mouse advanced to can be a really time consuming operation, always use cache. If the <code>Layer</code> knows that the image didn't change, recall the previously rendered <code>cv::Mat</code> from member variable <code>Cache</code>. An example showing this:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">void</span> <span class="pl-en">ShowImageLayer::Render</span>(<span class="pl-k">const</span> ProcessingStateDescriptor &amp;psd)
{
    <span class="pl-k">bool</span> dirty = <span class="pl-c1">true</span>;

    <span class="pl-k">if</span> (Cache.<span class="pl-smi">data</span> == <span class="pl-v">nullptr</span>) {
        cv::Mat imgOriginal = <span class="pl-c1">cv::imread</span>(psd.<span class="pl-smi">ImageFileName</span>, CV_LOAD_IMAGE_COLOR);
        <span class="pl-c1">Q_ASSERT</span>(imgOriginal.<span class="pl-smi">data</span>);

        Cache = imgOriginal;
    } <span class="pl-k">else</span> {
        dirty = <span class="pl-c1">false</span>;
    }

    emit <span class="pl-smi">RenderReady</span>(<span class="pl-c1">GetTargetCanvas</span>(), <span class="pl-c1">GetSequence</span>(), Cache, <span class="pl-c1">GetOpacity</span>(), dirty);
}</pre></div>

<p>Beware, that your condition on invalidating the cache might be different.</p>

<p>Supposedly, your cache depends on the very image file. If a new one got loaded, the cache has to be invalidated. In this case you simply have to override the appropriate function <code>FileOpened</code>. It is defined in classes <code>Processor</code>, <code>Layer</code> and <code>ImageProvider</code>:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Processor::FileOpened</span>(<span class="pl-k">const</span> QString&amp; fileName);
<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Layer::FileOpened</span>(<span class="pl-k">const</span> QString&amp; fileName);
<span class="pl-k">void</span> <span class="pl-en">ImageProvider::FileOpened</span>(<span class="pl-k">const</span> QString&amp; fileName);</pre></div>

<p>As soon as this function is invoked, you can be sure a new image file has been loaded already. Be careful as this function gets called both when an image file or a <code>.prc</code> file was opened. If it's needed for your class to differentiate between these formats, use the provided <code>fileName</code> parameter.</p>

<h3>
<a id="additional-canvases" class="anchor" href="#additional-canvases" aria-hidden="true"><span class="octicon octicon-link"></span></a>Additional canvases</h3>

<p>The system is capable of rendering layers not only on the main canvas but on arbitrary number of canvases.</p>

<p>Note that if your processor is set to receive mouse events, these are forwarded from all the canvases. The originating canvas name is provided in the emitted signal. Be sure to distinguish among them while processing mouse events if your ProcessorSlot has layers which render on different canvases.</p>

<h4>
<a id="default-canvases" class="anchor" href="#default-canvases" aria-hidden="true"><span class="octicon octicon-link"></span></a>Default canvases</h4>

<p>There are two pre-defined canvases are already in the program, namely:</p>

<ol>
<li>The <em>main canvas</em>: this is that the users first meet after an image file is opened. By default all the layers render onto this canvas. If you specifically want to declare your layer to render on this one, use its unique name <code>mainCanvas</code>.</li>
<li>The second, by default supported one is the <em>supplementary canvas</em>. This is a little canvas mainly used as a magnifier of the original picture on the right hand side of the application. If you want your layer to render on this one, use its name <code>supplementaryCanvas</code>.</li>
</ol>

<h4>
<a id="making-layers-to-render-on-a-specific-canvas" class="anchor" href="#making-layers-to-render-on-a-specific-canvas" aria-hidden="true"><span class="octicon octicon-link"></span></a>Making layers to render on a specific canvas</h4>

<p>A layer is capable of rendering only on one canvas which has to be defined at compile time and must not be changed during application run.</p>

<p>By default it renders on the main canvas. If you want to specify another render target, override the following virtual function of your layer:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">virtual</span> QString <span class="pl-en">GetTargetCanvas</span>() <span class="pl-k">const</span>;</pre></div>

<p>Then return the target canvas name, e.g. <code>supplementaryCanvas</code>:</p>

<div class="highlight highlight-c++"><pre>QString <span class="pl-en">MyFirstLayer::GetTargetCanvas</span>() <span class="pl-k">const</span>
{
    <span class="pl-k">return</span> <span class="pl-c1">QStringLiteral</span>(<span class="pl-s"><span class="pl-pds">"</span>supplementaryCanvas<span class="pl-pds">"</span></span>);
}</pre></div>

<h4>
<a id="creating-a-new-canvas" class="anchor" href="#creating-a-new-canvas" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating a new canvas</h4>

<p>Only two simple places you have to extend when you want to create a new canvas:</p>

<ol>
<li>
<p><em>QML</em>: First of all, decide where the new canvas has to be displayed  and then create a <code>PsdCanvas</code> element there in the appropriate QML file. Set the object name to your new canvas name. Something like this:</p>

<div class="highlight highlight-qml"><pre><span class="pl-c1">PsdCanvas</span> {
<span class="pl-e">    objectName</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>histogram<span class="pl-pds">"</span></span>
    <span class="pl-c1">Layout</span>.<span class="pl-e">preferredWidth</span><span class="pl-k">:</span> <span class="pl-c1">250</span>
    <span class="pl-c1">Layout</span>.<span class="pl-e">preferredHeight</span><span class="pl-k">:</span> <span class="pl-c1">Layout</span>.<span class="pl-e">preferredWidth</span> / <span class="pl-c1">2</span>
}</pre></div>
</li>
<li><p>Right after that, just create a new entry in the <code>ImageProvider::CanvasNames</code> static container with your new canvas name. It is located in the beginning of the <code>ImageProvider.cpp</code> source file.</p></li>
</ol>

<p>After these two steps, you can use your layers to draw on your custom canvas described in the sub-chapter above.</p>

<h2>
<a id="debugging" class="anchor" href="#debugging" aria-hidden="true"><span class="octicon octicon-link"></span></a>Debugging</h2>

<p>For every sane developer the time will come to log. Everything. Ok, maybe not the register contents.</p>

<p>GrainAutLine supports logging in two simultaneous ways:</p>

<ul>
<li>both to the standard output (to the <code>stderr</code>, to be precise)</li>
<li>and to the GUI.</li>
</ul>

<p>Each log message has to fall into one of these four distinct <em>types</em>:</p>

<table>
<thead>
<tr>
<th>Constant</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>QtDebugMsg</td>
<td>A message generated by the <a href="http://doc.qt.io/qt-5/qtglobal.html#qDebug">qDebug</a>() function.</td>
</tr>
<tr>
<td>QtWarningMsg</td>
<td>A message generated by the <a href="http://doc.qt.io/qt-5/qtglobal.html#qWarning">qWarning</a>() function.</td>
</tr>
<tr>
<td>QtCriticalMsg</td>
<td>A message generated by the <a href="http://doc.qt.io/qt-5/qtglobal.html#qCritical">qCritical</a>() function.</td>
</tr>
<tr>
<td>QtFatalMsg</td>
<td>A message generated by the <a href="http://doc.qt.io/qt-5/qtglobal.html#qFatal">qFatal</a>() function. <br> After printing this out, the application terminates.</td>
</tr>
</tbody>
</table>

<p>For using the Qt debug facility, please refer to the links above.</p>

<p>A <em>category</em> can also be associated with a message. If you want to distinguish messages based on categories, you just need to use the functions above with <code>C</code> like, <code>qCDebug()</code>, <code>qCWarning()</code> and so forth while providing the category as a parameter. An example:</p>

<div class="highlight highlight-c++"><pre><span class="pl-en">qCDebug</span>(funCategory) &lt;&lt; "Take one down and pass it around," &lt;&lt; remainingBeers &lt;&lt; "bottles of beer on the wall.";</pre></div>

<p>Don't forget that <code>qDebug()</code> takes care of the spaces and newlines for you.</p>

<h3>
<a id="defining-own-categories" class="anchor" href="#defining-own-categories" aria-hidden="true"><span class="octicon octicon-link"></span></a>Defining own categories</h3>

<p>Creating and maintaining your own category has it perks. For example you can create debug messages everywhere that only you can see and don't disturb the others with them.</p>

<p>To create a new category, just append the following line to <code>LogCategories.h</code>:</p>

<div class="highlight highlight-c++"><pre><span class="pl-en">Q_DECLARE_LOGGING_CATEGORY</span>(developerName)</pre></div>

<p>And its pair to <code>LogCategories.cpp</code>:</p>

<div class="highlight highlight-c++"><pre><span class="pl-en">Q_LOGGING_CATEGORY</span>(developerName, <span class="pl-s"><span class="pl-pds">"</span>dev.developerName<span class="pl-pds">"</span></span>, QtWarningMsg)</pre></div>

<p>From now on you are eligible to use logging functions like this: <code>qCDebug(developerName)</code> or <code>qCCritical(developerName)</code>.</p>

<ol>
<li>The first parameter (<code>developerName</code>) is the short name of the category which you can use in the program.</li>
<li>The second parameter (<code>dev.developerName</code>) will be shown on the GUI and on the console run-time. Since it's a regular string, it can contain spaces.</li>
<li>The third parameter tells the minimum logging level. The example above logs only warning messages and everything above it (i.e. ignoring <code>QtDebugMsg</code>-type calls).</li>
</ol>

<p>Unfortunately, turning them on and off conveniently from a preferences file is currently not supported. Please, check back later for it.</p>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

