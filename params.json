{"name":"GrainAutLine documentation","tagline":"","body":"# My first „Hello World!” processor!\r\n\r\nThis guide will show you how to create the new processor of yours, add some layers to it and set their properties.\r\n\r\n*A bit of disclaimer: this guide will continuously evolve as developer documentations do. But hey, it exists! So it worth to come back from time to time or subscribe to its change-notification. The latest state of this text always reflects the HEAD version of branch „szotsaki”. Generally speaking, if something doesn't work for you, just merge and recompile everything.*\r\n\r\n## So, the basics\r\nYou want to write a processor which does some calculations. You also want to show your work and later maybe interact with it on the GUI. For all of these you are needed to deal with three classes:\r\n\r\n1. `Processor`: of course this is the most important one. All the essence of your work goes mostly here.\r\n2. `Layer`: if you want some show-off, you'll also need this. Or these. You have the possibility to attach more layers to a processor. Or none. It's truly your choice whether you want to show something to the world.\r\n3. `ProcessorSlot`: last but not least, a structure is needed which encompasses these aforementioned classes together. You won't need to care about this much though, its defaults are just perfect.\r\n\r\n### Processors\r\nFirst, start with the `Processor`. It has a *name* and arbitrary number of custom *properties*. The processor-related files are stored with the model, in the <tt>MarbeCommon/Processors</tt> directory. To create your first processor, let's call it `FirstProcessor`, you have to subclass from the abstract `Processor` class like this:\r\n\r\n```c++\r\nclass FirstProcessor : public Processor\r\n{\r\n    Q_OBJECT\r\npublic:\r\n    FirstProcessor(QObject *parent = nullptr);\r\n    ~FirstProcessor() = default;\r\n}\r\n```\r\n\r\nThe `Q_OBJECT` macro is necessary because of some boring administration reasons. The `parent` pointer is necessary because [Qt](http://www.qt.io/) maintains a hierarchy of the declared objects for easier deletion among others. After that you see the constructor and destructor. Here is, how to define this class:\r\n\r\n```c++\r\nFirstProcessor::FirstProcessor(QObject *parent)\r\n    : Processor(\"My first Processor\", parent)\r\n{\r\n}\r\n```\r\n\r\nWe pass the name of our processor (which will be shown on the GUI) to the parent constructor.\r\n\r\n### Layers\r\nNow, head towards to the `Layers`.\r\n\r\nThe resemblance is uncanny with the processors. You will just have to create a new `Layer` class of yours (call it, for the sake of simplicity, `FirstLayer`), make it a descendant of the `Layer` abstract class and pass your *layer's name* to the parent constructor. The layer-related files lie with other GUI files, in the <tt>GrainAutLine/Layers</tt> directory. A very basic implementation would look like this:\r\n\r\n```c++\r\nclass FirstLayer : public Layer\r\n{\r\n    Q_OBJECT\r\npublic:\r\n    explicit FirstLayer(QObject *parent = nullptr);\r\n    ~FirstLayer() = default;\r\n}\r\n```\r\n\r\n```c++\r\nFirstLayer::FirstLayer(QObject *parent)\r\n    : Layer(\"My first layer\", parent)\r\n{\r\n}\r\n```\r\n\r\n### The ProcessorSlot\r\nLet's finish with the encapsulating class, the `ProcessorSlot`.\r\n\r\nFirst, you need to shortly name your work you did so far. The name of the compilation will appear only in code but it should be expressive for other developers. Register this name in the `ProcessorSlot::Type` enumeration. Now you can create a new specific instance of `ProcessorSlot`: please, usher yourself to the hall of the `ProcessorSlot` constructor and supplement the switch-case structure with the name of your choice.\r\n\r\nThe `Processor_` variable will hold your custom processor. Create a new instance of it:\r\n```c++\r\nProcessor_ = std::make_shared<FirstProcessor>(this);\r\n```\r\nThe `Layers` vector holds all the layers you want to use later. Previously we created only one, `FirstLayer`, but feel free to either add it multiple times or create many different layers later and add them here:\r\n```c++\r\nLayers.push_back(std::make_shared<FirstLayer>(this));\r\n```\r\n\r\nNote that layers are optional extensions for a `Processor` determined to show the internal state of the latter. Therefore it's not necessary to attach a layer at all.\r\n\r\n### The almighty encapsulator: the SlotManager\r\nMaybe there's a slight chance you've been wondering if there is an encapsulation class for `Layers` and `Processors` (this is the `ProcessorSlot`), is there a similar container for many `ProcessorSlots`? Yes, there is. It is called `SlotManager` which, not surprisingly, manages the life cycles of `ProcessorSlots`.\r\n\r\nWhen you are ready with your modifications so far, you are needed to register your `ProcessorSlot` in `SlotManager`. This is quite easy, just add your class to the following container in its constructor like this:\r\n```c++\r\nNonElementarySlots.push_back(\r\n    std::make_shared<ProcessorSlot>(ProcessorSlot::Type::MyFirstProcessorSlot, this)\r\n  );\r\n```\r\n\r\nMake sure that you replace `MyFirstProcessorSlot` with the name you used previously in the enumeration.\r\n\r\n### Finishing\r\n\r\nYou created a new  `Processor` and a new `Layer`. Then you added them to the their encapsulation class, `ProcessorSlot`. After that you registered this processor slot at their manager, `SlotManager`.\r\n\r\nNow, we are ready. Oh, just one thing: make sure that your processor computes and layer draws. How easy to say that, isn't it? Well, it will surely be a joyful journey. For the beginning, define and override the following functions:\r\n- for the computation itself:\r\n```c++\r\nvirtual bool FirstProcessor::Step(ProcessingStateDescriptor& psd) override;\r\n```\r\n- and for the drawing:\r\n```c++\r\nvirtual void FirstLayer::Render(const ProcessingStateDescriptor& psd) override;\r\n```\r\n\r\nHave a nice time coding!\r\n\r\n# Reference documentation\r\n\r\nFrom now on, we are going through the different trifles of the API to make you get most out of the programming interface.\r\n\r\n## ProcessorSlot\r\nAs we saw previously, a `ProcessorSlot` encompasses exactly one `Processor` and an arbitrary number of `Layers`.\r\n\r\n### Elementary ProcessorSlots\r\nAn *elementary* `ProcessorSlot` has the following properties:\r\n- Its `Processor` always runs regardless of everything. This is necessary for making such fundamental tasks done like the raw image rendering. This means that:\r\n-- its `Processor` will run after a non-elementary `Processor`;\r\n-- and unconditionally after a key or mouse event occurred.\r\n- Its `Processor` name doesn't show up in the drop-down processor selector list on the GUI, so it cannot be selected to run alone.\r\n- This infers that an elementary `Processor` cannot have properties configured from the GUI, since its property window will never be displayed.\r\n- Nevertheless, it still can have as many layers as you want and these layers are always shown until the user decides to turn them off.\r\n\r\nTo make a `ProcessorSlot` elementary, just set the `Elementary_` variable to `true` in the `ProcessorSlot` constructor. Just like the following example does:\r\n\r\n```c++\r\n[…]\r\ncase Type::ShowImage:\r\n        Processor_ = std::make_shared<ShowImageProcessor>(this);\r\n        Layers.push_back(std::make_shared<ShowImageLayer>(this));\r\n        Elementary_ = true;\r\n        break;\r\n[…]\r\n```\r\nThis property cannot be modified at run-time.\r\n\r\nPlease, pay attention to instantiate your elementary `ProcessorSlot` in the right section of the `SlotManager` constructor. A comment line indicates where these are going.\r\n\r\n## Processor\r\n\r\n### Processor properties\r\n\r\nA processor is a rather complex entity, therefore it needs some *properties* to fine-tune itself. These properties are shown on the GUI and freely configurable by the user. All properties have a unique *name*, a *default value* and of course they hold their *current value*.\r\n\r\nTo add a property to your `Processor`, simply call the `AddProperty` method in your `Processor` constructor.\r\n\r\nCurrently, there are two different kinds of properties you can use:\r\n\r\n1. *Float type*: You can store a `float` value inside with a *minimum* and *maximum* range provided.\r\n    ```c++\r\n    void AddProperty(const QString& name,\r\n                     const float minimum,\r\n                     const float maximum,\r\n                     const float default_);\r\n    ```\r\n    Reading its value is possible by its name with the following function:\r\n    ```c++\r\n    float GetFloatPropertyValue(const QString& name);\r\n    ```\r\n\r\n2. *Boolean type*: You can store a `bool` value inside.\r\n    ```c++\r\n    void AddProperty(const QString& name,\r\n                     const bool default_);\r\n    ```\r\n    Reading its value is possible by its name with the following function:\r\n    ```c++\r\n    bool GetBoolPropertyValue(const QString& name);\r\n    ```\r\n\r\n\r\n### Overriding Run()\r\nA `Processor` works this simplified way: when a mouse click occurred or a new image file was loaded, the `Run` method starts and calls `Step` until it returns `false`. If you need more elaborate control, you can override this method. Its default implementation looks like the following:\r\n\r\n```c++\r\nvoid Processor::Run(ProcessingStateDescriptor& psd)\r\n{\r\n    while(Step(psd) == true)\r\n        ;\r\n\r\n    emit ComputationReady(psd);\r\n}\r\n```\r\n\r\nPlease, always emit the `ComputationReady` signal when the `Run` process finishes.\r\n\r\n### Mouse handling\r\n\r\n#### Subscribing to the mouse events\r\n\r\nThere are four types of mouse events exist:\r\n\r\n| Constant                    | Description       |\r\n|-----------------------------|-------------------|\r\n| QEvent::MouseButtonPress    | Mouse press       |\r\n| QEvent::MouseButtonRelease  | Mouse release     |\r\n| QEvent::MouseButtonDblClick | Mouse press again |\r\n| QEvent::MouseMove           | Mouse move        |\r\n\r\nThe `MouseButtonRelease` is e.g. useful for one-shot actions like running the processor after a click was made at a certain coordinate. While the `MouseMove` is best for continuous actions like drawing. You can freely subscribe to each of them independently with your processor.\r\n\r\nBy default, a `Processor` doesn't receive these mouse events. To do so, add the desired ones to the `SubscribedMouseEvents` [`unordered_set`][unordered_set] structure like this:\r\n\r\n```c++\r\nSubscribedMouseEvents = {QEvent::MouseButtonRelease, QEvent::MouseMove};\r\n```\r\n\r\nYou may add them directly at the construction time of your class, although you can modify these values any time you want; the changes will come into effect before the next run of your `Processor`.\r\n\r\nPlease note that regardless whether you are subscribed to the mouse events, your non-elementary `Processor` won't receive them if it's not the currently selected one.\r\n\r\n#### Reacting to a mouse event\r\n\r\nSupposing you're already subscribed to the desired mouse events, your processor will receive them in the following `virtual` function:\r\n\r\n```c++\r\nvirtual void MouseEventOccurred(const QMouseEvent& event,\r\n                                const QString& canvasName,\r\n                                ProcessingStateDescriptor& psd)\r\n```\r\n\r\nThe first variable contains the event itself. You can determine its type by using the `type()` function of its. For example if you are subscribed to the previously mentioned events, you can distinguish between them in the following way:\r\n\r\n```c++\r\nvoid MyFirstProcessor::MouseEventOccurred(const QMouseEvent &event, const QString &canvasName, ProcessingStateDescriptor &psd)\r\n{\r\n    // Refresh the MouseEvent variable both on QEvent::MouseButtonRelease and QEvent::MouseMove\r\n    MouseEvent = event;\r\n\r\n    if (event.type() == QEvent::MouseButtonRelease) {\r\n        MouseClicked(canvasName, psd);\r\n    }\r\n}\r\n```\r\n\r\nThe default implementation of this function stores the `QMouseEvent` object into the `MouseEvent` member variable. In case you don't need extra handling of the events, you may not want to override this function, just read the `MouseEvent` member from your `Processor`.\r\n\r\nBy default a non-elementary `Processor` won't run after a mouse or keyboard event occurred. To force it, simply call `RunInThread()` where you want to start the computing like in this custom mouse click handler:\r\n\r\n```c++\r\nvoid MyFirstProcessor::MouseClicked(const QString &canvasName, ProcessingStateDescriptor &psd)\r\n{\r\n    Q_UNUSED(canvasName)\r\n\r\n    // This processor is also used to trigger re-rendering without modifying something\r\n    RunInThread(psd);\r\n}\r\n```\r\n\r\nWarning! Always make sure that the `ComputationReady` signal is emitted from a *non-elementary* processor's keyboard or mouse event handling function. It can be either a `RunInThread` call which automatically emits this signal at the end of its run or emit it manually. This guarantees the follow-up elementary processors will run and the screen is refreshed. An example for this:\r\n\r\n```c++\r\nvoid MyFirstProcessor::MouseEventOccurred(const QMouseEvent &event, const QString &canvasName, ProcessingStateDescriptor &psd)\r\n{\r\n    if (event.type() == QEvent::MouseButtonRelease) {\r\n        RunInThread(psd);\r\n    } else {\r\n        emit ComputationReady(psd);\r\n    }\r\n}\r\n```\r\n\r\n#### Getting the current mouse coordinates\r\n\r\nWhen a mouse event occurred and the processor is set to receive these events, by default the `MouseEvent` member contains the current event with its position. Use the `pos` or `localPos` functions to read out these coordinates. Please, refer to the [QMouseEvent][QMouseEvent] and [QPoint][QPoint] documentation on handling these values.\r\n\r\nPlease note that because of performance reasons functions `screenPos`, `windowPos` and `globalPos` always return with `QPoint(0, 0)`.\r\n\r\nThe top-left image coordinate is (0, 0) and the given coordinates are always resize-agnostics.\r\n\r\n## Layers\r\n\r\nA `Layer` renders a bit of portion of the main image which will be blended into the renderings of other layers. After all the layers created their own `cv::Mat` image, the so called `ImageProvider` collects and flattens them into the final image which will be shown to user on the canvas(es).\r\n\r\n### Accessing to its Processor\r\n\r\nIt is an easy task since it involves only calling the `GetProcessor` getter from anywhere inside the Layer's function. Calling this getter it's your responsibility to specify exactly that type of `Processor` which belongs to the current `Layer`. The return value of this function is a `std::shared_ptr` so handle it like a normal pointer type.\r\n\r\nAn example which calls the custom `CreateMagic()` function of your `FirstProcessor`:\r\n\r\n```c++\r\nGetProcessor<FirstProcessor>()->CreateMagic();\r\n```\r\n\r\n### Sequences\r\n\r\nEach `Layer` has a number, called `Sequence`. This defines the order of layers to render on each other. You can query this number if you need by using member function `GetSequence` but please, by any means, do *not* ever change this value!\r\n\r\n### Rendering\r\n\r\nThis is the function in you are free to leverage your creativity. One thing you need to pay a bit attention to: emit the *iAmReadyWithRendering* signal, here called `RenderReady` if you want your layer image to be shown. For example like this:\r\n\r\n```c++\r\nvoid FirstLayer::Render(const ProcessingStateDescriptor& psd)\r\n{\r\n    // Generate image to cv::Mat\r\n    const cv::Mat image = psd.ExportToImage(\"\");\r\n\r\n    emit RenderReady(GetTargetCanvas(), GetSequence(), image, GetOpacity(), true);\r\n}\r\n```\r\n\r\nThe signal signature is the following:\r\n```c++\r\nvoid RenderReady(const QString& canvasName, // Name of the canvas to draw on\r\n                 const int layerSequence,   // Sequence ID of the current layer\r\n                 const cv::Mat& mat,        // The finished image in cv::Mat format\r\n                 const float opacity,       // Opacity of the current layer set on the GUI\r\n                 const bool dirty);         // true only if the cv::Mat has been changed\r\n```\r\n\r\n### Caching\r\n\r\nSince converting many cv::Mats from the processors on every pixel the mouse advanced to can be a really time consuming operation, always use cache. If the `Layer` knows that the image didn't change, recall the previously rendered `cv::Mat` from member variable `Cache`. An example showing this:\r\n\r\n```c++\r\nvoid ShowImageLayer::Render(const ProcessingStateDescriptor &psd)\r\n{\r\n    bool dirty = true;\r\n\r\n    if (Cache.data == nullptr) {\r\n        cv::Mat imgOriginal = cv::imread(psd.ImageFileName, CV_LOAD_IMAGE_COLOR);\r\n        Q_ASSERT(imgOriginal.data);\r\n\r\n        Cache = imgOriginal;\r\n    } else {\r\n        dirty = false;\r\n    }\r\n\r\n    emit RenderReady(GetTargetCanvas(), GetSequence(), Cache, GetOpacity(), dirty);\r\n}\r\n```\r\n\r\nBeware, that your condition on invalidating the cache might be different.\r\n\r\nSupposedly, your cache depends on the very image file. If a new one got loaded, the cache has to be invalidated. In this case you simply have to override the appropriate function `FileOpened`. It is defined in classes `Processor`, `Layer` and `ImageProvider`:\r\n\r\n```c++\r\nvirtual void Processor::FileOpened(const QString& fileName);\r\nvirtual void Layer::FileOpened(const QString& fileName);\r\nvoid ImageProvider::FileOpened(const QString& fileName);\r\n```\r\n\r\nAs soon as this function is invoked, you can be sure a new image file has been loaded already. Be careful as this function gets called both when an image file or a `.prc` file was opened. If it's needed for your class to differentiate between these formats, use the provided `fileName` parameter.\r\n\r\n### Additional canvases\r\n\r\nThe system is capable of rendering layers not only on the main canvas but on arbitrary number of canvases.\r\n\r\nNote that if your processor is set to receive mouse events, these are forwarded from all the canvases. The originating canvas name is provided in the emitted signal. Be sure to distinguish among them while processing mouse events if your ProcessorSlot has layers which render on different canvases.\r\n\r\n#### Default canvases\r\n\r\nThere are two pre-defined canvases are already in the program, namely:\r\n\r\n1. The *main canvas*: this is that the users first meet after an image file is opened. By default all the layers render onto this canvas. If you specifically want to declare your layer to render on this one, use its unique name `mainCanvas`.\r\n2. The second, by default supported one is the *supplementary canvas*. This is a little canvas mainly used as a magnifier of the original picture on the right hand side of the application. If you want your layer to render on this one, use its name `supplementaryCanvas`.\r\n\r\n#### Making layers to render on a specific canvas\r\n\r\nA layer is capable of rendering only on one canvas which has to be defined at compile time and must not be changed during application run.\r\n\r\nBy default it renders on the main canvas. If you want to specify another render target, override the following virtual function of your layer:\r\n\r\n```c++\r\nvirtual QString GetTargetCanvas() const;\r\n```\r\n\r\nThen return the target canvas name, e.g. `supplementaryCanvas`:\r\n```c++\r\nQString MyFirstLayer::GetTargetCanvas() const\r\n{\r\n    return QStringLiteral(\"supplementaryCanvas\");\r\n}\r\n```\r\n\r\n#### Creating a new canvas\r\n\r\nOnly two simple places you have to extend when you want to create a new canvas:\r\n\r\n1. *QML*: First of all, decide where the new canvas has to be displayed  and then create a `PsdCanvas` element there in the appropriate QML file. Set the object name to your new canvas name. Something like this:\r\n\r\n    ```qml\r\n    PsdCanvas {\r\n        objectName: \"histogram\"\r\n        Layout.preferredWidth: 250\r\n        Layout.preferredHeight: Layout.preferredWidth / 2\r\n    }\r\n    ```\r\n\r\n2. Right after that, just create a new entry in the `ImageProvider::CanvasNames` static container with your new canvas name. It is located in the beginning of the `ImageProvider.cpp` source file.\r\n\r\nAfter these two steps, you can use your layers to draw on your custom canvas described in the sub-chapter above.\r\n\r\n## Debugging\r\n\r\nFor every sane developer the time will come to log. Everything. Ok, maybe not the register contents.\r\n\r\nGrainAutLine supports logging in two simultaneous ways:\r\n- both to the standard output (to the `stderr`, to be precise)\r\n- and to the GUI.\r\n\r\nEach log message has to fall into one of these four distinct *types*:\r\n\r\n| Constant      | Description                                                   |\r\n|---------------|---------------------------------------------------------------|\r\n| QtDebugMsg    | A message generated by the [qDebug][qDebug]() function.       |\r\n| QtWarningMsg  | A message generated by the [qWarning][qWarning]() function.   |\r\n| QtCriticalMsg | A message generated by the [qCritical][qCritical]() function. |\r\n| QtFatalMsg    | A message generated by the [qFatal][qFatal]() function. <br/> After printing this out, the application terminates. |\r\n\r\nFor using the Qt debug facility, please refer to the links above.\r\n\r\nA *category* can also be associated with a message. If you want to distinguish messages based on categories, you just need to use the functions above with `C` like, `qCDebug()`, `qCWarning()` and so forth while providing the category as a parameter. An example:\r\n\r\n```c++\r\nqCDebug(funCategory) << \"Take one down and pass it around,\" << remainingBeers << \"bottles of beer on the wall.\";\r\n```\r\n\r\nDon't forget that `qDebug()` takes care of the spaces and newlines for you.\r\n\r\n### Defining own categories\r\n\r\nCreating and maintaining your own category has it perks. For example you can create debug messages everywhere that only you can see and don't disturb the others with them.\r\n\r\nTo create a new category, just append the following line to `LogCategories.h`:\r\n\r\n```c++\r\nQ_DECLARE_LOGGING_CATEGORY(developerName)\r\n```\r\n\r\nAnd its pair to `LogCategories.cpp`:\r\n\r\n```c++\r\nQ_LOGGING_CATEGORY(developerName, \"dev.developerName\", QtWarningMsg)\r\n```\r\n\r\nFrom now on you are eligible to use logging functions like this: `qCDebug(developerName)` or `qCCritical(developerName)`.\r\n\r\n1. The first parameter (`developerName`) is the short name of the category which you can use in the program.\r\n2. The second parameter (`dev.developerName`) will be shown on the GUI and on the console run-time. Since it's a regular string, it can contain spaces.\r\n3. The third parameter tells the minimum logging level. The example above logs only warning messages and everything above it (i.e. ignoring `QtDebugMsg`-type calls).\r\n\r\nUnfortunately, turning them on and off conveniently from a preferences file is currently not supported. Please, check back later for it.\r\n\r\n[qDebug]: http://doc.qt.io/qt-5/qtglobal.html#qDebug\r\n[qWarning]: http://doc.qt.io/qt-5/qtglobal.html#qWarning\r\n[qCritical]: http://doc.qt.io/qt-5/qtglobal.html#qCritical\r\n[qFatal]: http://doc.qt.io/qt-5/qtglobal.html#qFatal\r\n[QPoint]: http://doc.qt.io/qt-5/qpoint.html\r\n[QMouseEvent]: http://doc.qt.io/qt-5/qmouseevent.html\r\n[unordered_set]: http://www.cplusplus.com/reference/unordered_set/unordered_set/","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}