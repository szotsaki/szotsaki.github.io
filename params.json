{"name":"GrainAutLine documentation","tagline":"","body":"# My first „Hello World!” processor!\r\n\r\nThis guide will show you how to create the new processor of yours, add some layers to it and set their properties.\r\n\r\n*A bit of disclaimer: this guide will continuously evolve as developer documentations do. But hey, it exists! So it worth to come back from time to time or subscribe to its change-notification. The latest state of this text always reflects the HEAD version of branch „szotsaki”. Generally speaking, if something doesn't work for you, just merge and recompile everything.*\r\n\r\n## So, the basics\r\nYou want to write a processor which does some calculations. You also want to show your work and later maybe interact with it on the GUI. For all of these you are needed to deal with three classes:\r\n\r\n1. `Processor`: of course this is the most important one. All the essence of your work goes mostly here.\r\n2. `Layer`: if you want some show-off, you'll also need this. Or these. You have the possibility to attach more layers to a processor. Or none. It's truly your choice whether you want to show something to the world.\r\n3. `ProcessorSlot`: last but not least, a structure is needed which encompasses these aforementioned classes together. You won't need to care about this much though, its defaults are just perfect.\r\n\r\n### Processors\r\nFirst, start with the `Processor`. It has a *name* and arbitrary number of custom *properties*. The processor-related files are stored with the model, in the <tt>MarbeCommon/Processors</tt> directory. To create your first processor, let's call it `FirstProcessor`, you have to subclass from the abstract `Processor` class like this:\r\n\r\n```c++\r\nclass FirstProcessor : public Processor\r\n{\r\n    Q_OBJECT\r\npublic:\r\n    FirstProcessor(QObject *parent = nullptr);\r\n    ~FirstProcessor() = default;\r\n}\r\n```\r\n\r\nThe `Q_OBJECT` macro is necessary because of some boring administration reasons. The `parent` pointer is necessary because [Qt](http://www.qt.io/) maintains a hierarchy of the declared objects for easier deletion among others. After that you see the constructor and destructor. Here is, how to define this class:\r\n\r\n```c++\r\nFirstProcessor::FirstProcessor(QObject *parent)\r\n    : Processor(\"My first Processor\", parent)\r\n{\r\n}\r\n```\r\n\r\nWe pass the name of our processor (which will be shown on the GUI) to the parent constructor.\r\n\r\n### Layers\r\nNow, head towards to the `Layers`.\r\n\r\nThe resemblance is uncanny with the processors. You will just have to create a new `Layer` class of yours (call it, for the sake of simplicity, `FirstLayer`), make it a descendant of the `Layer` abstract class and pass your *layer's name* to the parent constructor. The layer-related files lie with other GUI files, in the <tt>GrainAutLine/Layers</tt> directory. A very basic implementation would look like this:\r\n\r\n```c++\r\nclass FirstLayer : public Layer\r\n{\r\n    Q_OBJECT\r\npublic:\r\n    explicit FirstLayer(QObject *parent = nullptr);\r\n    ~FirstLayer() = default;\r\n}\r\n```\r\n\r\n```c++\r\nFirstLayer::FirstLayer(QObject *parent)\r\n    : Layer(\"My first layer\", parent)\r\n{\r\n}\r\n```\r\n\r\n### The ProcessorSlot\r\nLet's finish with the encapsulating class, the `ProcessorSlot`.\r\n\r\nFirst, you need to shortly name your work you did so far. The name of the compilation will appear only in code but it should be expressive for other developers. Register this name in the `ProcessorSlot::Type` enumeration. Now you can create a new specific instance of `ProcessorSlot`: please, usher yourself to the hall of the `ProcessorSlot` constructor and supplement the switch-case structure with the name of your choice.\r\n\r\nThe `Processor_` variable will hold your custom processor. Create a new instance of it:\r\n```c++\r\nProcessor_ = std::make_shared<FirstProcessor>(this);\r\n```\r\nThe `Layers` vector holds all the layers you want to use later. Previously we created only one, `FirstLayer`, but feel free to either add it multiple times or create many different layers later and add them here:\r\n```c++\r\nLayers.push_back(std::make_shared<FirstLayer>(this));\r\n```\r\n\r\nNote that layers are optional extensions for a `Processor` determined to show the internal state of the latter. Therefore it's not necessary to attach a layer at all.\r\n\r\n### The almighty encapsulator: the SlotManager\r\nMaybe there's a slight chance you've been wondering if there is an encapsulation class for `Layers` and `Processors` (this is the `ProcessorSlot`), is there a similar container for many `ProcessorSlots`? Yes, there is. It is called `SlotManager` which, not surprisingly, manages the life cycles of `ProcessorSlots`.\r\n\r\nWhen you are ready with your modifications so far, you are needed to register your `ProcessorSlot` in `SlotManager`. This is quite easy, just add your class to the following container in its constructor like this:\r\n```c++\r\nNonElementarySlots.push_back(\r\n    std::make_shared<ProcessorSlot>(ProcessorSlot::Type::MyFirstProcessorSlot, this)\r\n  );\r\n```\r\n\r\nMake sure that you replace `MyFirstProcessorSlot` with the name you used previously in the enumeration.\r\n\r\n### Finishing\r\n\r\nYou created a new  `Processor` and a new `Layer`. Then you added them to the their encapsulation class, `ProcessorSlot`. After that you registered this processor slot at their manager, `SlotManager`.\r\n\r\nNow, we are ready. Oh, just one thing: make sure that your processor computes and layer draws. How easy to say that, isn't it? Well, it will surely be a joyful journey. For the beginning, define and override the following functions:\r\n- for the computation itself:\r\n```c++\r\nvirtual bool FirstProcessor::Step(ProcessingStateDescriptor& psd) override;\r\n```\r\n- and for the drawing:\r\n```c++\r\nvirtual void FirstLayer::Render(const ProcessingStateDescriptor& psd) override;\r\n```\r\n\r\nHave a nice time coding!\r\n\r\n# Reference documentation\r\n\r\nFrom now on, we are going through the different trifles of the API to make you get most out of the programming interface.\r\n\r\n## ProcessorSlot\r\nAs we saw previously, a `ProcessorSlot` encompasses exactly one `Processor` and an arbitrary number of `Layers`.\r\n\r\n### Elementary ProcessorSlots\r\nAn *elementary* `ProcessorSlot` has the following properties:\r\n- Its `Processor` always runs regardless of everything. This is necessary for making such fundamental tasks done like the raw image rendering.\r\n- Its `Processor` name doesn't show up in the drop-down processor selector list on the GUI, so it cannot be selected to run alone.\r\n- This infers that an elementary `Processor` cannot have properties configured from the GUI, since its property window will never be displayed.\r\n- Nevertheless, it still can have as many layers as you want and these layers are always shown until the user decides to turn them off.\r\n- An elementary `ProcessorSlot` (and its containees) by default don't receive mouse events, however this can be configured in `SlotManager` constructor following to the comment there.\r\n\r\nTo make a `ProcessorSlot` elementary, just set the `Elementary_` variable to `true` in the `ProcessorSlot` constructor. Just like the following example does:\r\n\r\n```c++\r\n[…]\r\ncase Type::ShowImage:\r\n        Processor_ = std::make_shared<ShowImageProcessor>(this);\r\n        Layers.push_back(std::make_shared<ShowImageLayer>(this));\r\n        Elementary_ = true;\r\n        break;\r\n[…]\r\n```\r\nThis property cannot be modified at run-time.\r\n\r\nPlease, pay attention to instantiate your elementary `ProcessorSlot` in the right section of the `SlotManager` constructor. A comment line indicates where these are going.\r\n\r\n### Supplementary canvas\r\n\r\nA *supplementary canvas* is a small area displaying custom layers which is bound to a `ProcessorSlot` and shown on the right hand side of the GUI.\r\n\r\nThis feature is under construction; please check back a while later for documentation.\r\n\r\n## Processor\r\n\r\n### Processor properties\r\n\r\nA processor is a rather complex entity, therefore it needs some *properties* to fine-tune itself. These properties are shown on the GUI and freely configurable by the user. All properties have a unique *name*, a *default value* and of course they hold their *current value*.\r\n\r\nTo add a property to your `Processor`, simply call the `AddProperty` method in your `Processor` constructor.\r\n\r\nCurrently, there are two different kinds of properties you can use:\r\n\r\n1. *Float type*: You can store a `float` value inside with a *minimum* and *maximum* range provided.\r\n    ```c++\r\n    void AddProperty(const QString& name,\r\n                     const float minimum,\r\n                     const float maximum,\r\n                     const float default_);\r\n    ```\r\n    Reading its value is possible by its name with the following function:\r\n    ```c++\r\n    float GetFloatPropertyValue(const QString& name);\r\n    ```\r\n\r\n2. *Boolean type*: You can store a `bool` value inside.\r\n    ```c++\r\n    void AddProperty(const QString& name,\r\n                     const bool default_);\r\n    ```\r\n    Reading its value is possible by its name with the following function:\r\n    ```c++\r\n    bool GetBoolPropertyValue(const QString& name);\r\n    ```\r\n\r\n\r\n### Overriding Run()\r\nA `Processor` works this simplified way: when a mouse click occurred or a new image file was loaded, the `Run` method starts and calls `Step` until it returns `false`. If you need more elaborate control, you can override this method. Its default implementation looks like the following:\r\n\r\n```c++\r\nvoid Processor::Run(ProcessingStateDescriptor& psd)\r\n{\r\n    while(Step(psd) == true)\r\n        ;\r\n\r\n    emit ComputationReady(psd);\r\n}\r\n```\r\n\r\nPlease, always emit the `ComputationReady` signal when the `Run` process finishes.\r\n\r\n### Subscribing to the mouse events\r\n\r\nThere are two types of mouse events exist:\r\n\r\n- mouse *click* and\r\n- mouse click and move while holding, here called mouse *click and drag*.\r\n\r\nThe first one is useful for one-shot actions like running the processor after a click was made at a certain coordinate. The latter is best for continuous actions like drawing. You can freely subscribe to each of them independently with your processor.\r\n\r\nBy default, a `Processor` doesn't receive these mouse events. To do so, redefine its `ReceiveMouseClick` or  `ReceiveMouseClickAndDrag` function and return with true. You can modify its return value any time you want, the changes will come to effect when a new `Processor` is selected on the GUI.\r\n\r\nPlease note that regardless you are subscribed to the mouse events, your `Processor` won't receive them if it's not the currently selected one.\r\n\r\nPlease also note that this sub-chapter only applies to non-elementary processors. For elementary processors refer to the [Elementary ProcessorSlots](#elementary-processorslots)  chapter.\r\n\r\n### Run on a mouse event\r\n\r\nVirtual functions `MouseClicked` and `MouseClickedAndDragged` are implemented in a way if the `Processor` receives the event, store the coordinates. After that the current `Processor` will run as well as the elementary processors for drawing and blending the resulting image.\r\n\r\nThese functions are automatically called if a click or a drag event occurred and the `Processor` was subscribed to it.\r\n\r\nIf you want another behaviour, override these `protected` functions:\r\n```c++\r\nvirtual void MouseClicked(const QString& canvasName,\r\n                          const QPointF& coordinates,\r\n                          ProcessingStateDescriptor& psd)\r\n```\r\n\r\n```c++\r\nvirtual void MouseClickedAndDragged(const QString& canvasName,\r\n                                    const QPointF& coordinates,\r\n                                    ProcessingStateDescriptor& psd)\r\n```\r\n\r\n### Getting the current mouse coordinates\r\n\r\nWhen a mouse click or drag occurred and the processor is set to receive these events, you can be sure that the `MouseCoordinates` member contains the current position. If no click occurred (e.g. after an image loaded), this member contains the (0, 0) coordinate.\r\n\r\nThe top-left image coordinate is (0, 0).\r\n\r\nOn reading out the value from this member, please refer to the [QPointF documentation](http://doc.qt.io/qt-5/qpointf.html).\r\n\r\n## Layers\r\n\r\nA `Layer` renders a bit of portion of the main image which will be blended into the renderings of other layers. After all the layers created their own `cv::Mat` image, the so called `ImageProvider` collects and flattens them into the final image which will be shown to user on the canvas(es).\r\n\r\nThe layer concept is under construction, so the documentation is unfinished yet.\r\n\r\n### Accessing to its Processor\r\n\r\nIt is an easy task since it involves only calling the `GetProcessor` getter from anywhere inside the Layer's function. Calling this getter it's your responsibility to specify exactly that type of `Processor` which belongs to the current `Layer`. The return value of this function is a `std::shared_ptr` so handle it like a normal pointer type.\r\n\r\nAn example which calls the custom `CreateMagic()` function of your `FirstProcessor`:\r\n\r\n```c++\r\nGetProcessor<FirstProcessor>()->CreateMagic();\r\n```\r\n\r\n### Sequences\r\n\r\nEach `Layer` has a number, called `Sequence`. This defines the order of layers to render on each other. You can query this number if you need by using member function `GetSequence` but please, by any means, do *not* ever change this value!\r\n\r\n### Rendering\r\n\r\nThis is the function in you are free to leverage your creativity. One thing you need to pay a bit attention to: emit the *iAmReadyWithRendering* signal, here called `RenderReady` if you want your layer image to be shown. For example like this:\r\n\r\n```c++\r\nvoid FirstLayer::Render(const ProcessingStateDescriptor& psd)\r\n{\r\n    // Generate image to cv::Mat\r\n    const cv::Mat image = psd.ExportToImage(\"\");\r\n\r\n    emit RenderReady(GetSequence(), image, true);\r\n}\r\n```\r\n\r\nThe signal signature is the following:\r\n```c++\r\nvoid RenderReady(const int layerSequence, // Sequence ID of the current layer\r\n                 const cv::Mat& mat,      // The finished image in cv::Mat format\r\n                 const bool dirty);       // true only if the cv::Mat has been changed\r\n```\r\n\r\n### Caching\r\n\r\nSince converting many cv::Mats from the processors on every pixel the mouse advanced to can be a really time consuming operation, always use cache. If the `Layer` knows that the image didn't change, recall the previously rendered `cv::Mat` from member variable `Cache`. An example showing this:\r\n\r\n```c++\r\nvoid ShowImageLayer::Render(const ProcessingStateDescriptor &psd)\r\n{\r\n    bool dirty = true;\r\n\r\n    if (Cache.data == nullptr) {\r\n        cv::Mat imgOriginal = cv::imread(psd.ImageFileName, CV_LOAD_IMAGE_COLOR);\r\n        Q_ASSERT(imgOriginal.data);\r\n\r\n        Cache = imgOriginal;\r\n    } else {\r\n        dirty = false;\r\n    }\r\n\r\n    emit RenderReady(GetSequence(), Cache, dirty);\r\n}\r\n```\r\n\r\nBeware that your condition on invalidating the cache might be different.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}